{"projectName":"schedule","datapackDirectory":null,"resourcesPackDirectory":null,"offuscate":true,"isLibrary":true,"description":"","files":[{"name":"import","content":"","index":0},{"name":"schedule","content":"package schedule\n\ndef lazy clear(function $func){\n    /schedule clear $func.name\n}\ndef lazy remove(function $func){\n    /schedule clear $func.name\n}\ndef lazy add(function $func){\n    /schedule function $func.name 1t append\n}\ndef lazy add(function $func, int $t){\n    define int $t2 = $tt\n    define int $t3 = regex($t2, \"dt\",\"d\")\n    define int $t4 = regex($t3, \"tt\",\"t\")\n    define int $t5 = regex($t4, \"st\",\"s\")\n    /schedule function $func.name $t5 append\n}\ndef lazy add(function $func, int $t, int $unit){\n    /schedule function $func.name $t$unit append\n}\npackage .\ndef lazy delay(function $func, int $t){\n    schedule.add($func, $t)\n}\ndef lazy asyncrepeat(int $count, int=>void $func){\n    int count = 0\n    asyncwhile(count < $count){\n        $func(count)\n        count++\n    }\n}\ndef lazy asyncrepeat(int $count, int $dt, int=>void $func){\n    int count = 0\n    asyncwhile(count < $count, $dt){\n        $func(count)\n        count++\n    }\n}\n\n\ndef lazy asyncwhile(int $condition, function $func){\n    def __lambda__(){\n        $func()\n        if ($condition){\n            schedule.add(__lambda__)\n        }\n    }\n    if ($condition){\n        __lambda__()\n    }\n}\n\ndef lazy asyncwhile(int $condition, int $dlt, function $func){\n    def __lambda__(){\n        $func()\n        if ($condition){\n            schedule.add(__lambda__, $dlt)\n        }\n    }\n    if ($condition){\n        __lambda__()\n    }\n}\n\ndef lazy asyncwhile(int $condition, entity $sel, int $dlt, function $func){\n    def __lambda__(){\n        with($sel,true){\n            $func()\n        }\n        if ($condition){\n            schedule.add(__lambda__, $dlt)\n        }\n    }\n    if ($condition){\n        __lambda__()\n    }\n}","index":0},{"name":"process","content":"package process\n\ndef helper @after_test show(){\n    print((\"===[ Running Processes ]===\",green))\n    int running = 0\n    int off = 0\n    int unknown = 0\n    int total = 0\n    \n    forgenerate($i,@__process_count__){\n        t_running = 0\n        t_total = 0\n        $i()\n        if (t_running == 1){\n            print((\" [ON] $i\",green))\n            running++\n        }\n        else if (t_running == 0){\n            print((\" [OFF] $i\",red))\n            off++\n        }\n        else{\n            print((\" [??] $i\",yellow))\n            unknown++\n        }\n        total++\n    }\n    print((\"Stats: \",white),(f\"{running}/{total} Running\",green),(\" - \"), (f\"{off}/{total} Off\",red),(\" - \"),(f\"{unknown}/{total} Unknown\",yellow))\n}\n\nint t_running, t_total\nstatic abstract class process{\n    int enabled\n    int crashCount\n    void=>void callback\n    \n    loading reload(){\n        run()\n    }\n    def crash(){\n        exception.exception(\"Stack Overlow detect in Process. Try to increase the maxCommandChainLength\")\n        crashCount++\n        if (crashCount > 10){\n            exception.exception(\"Max Number of Stack Overflow reach. Process Killed.\")\n            enabled = 0\n        }\n        run()\n    }\n    def start(){\n        enabled:=false\n        if (!enabled){\n            enabled = true\n            onStart()\n            run()\n        }\n    }\n    def @__process_main__ run(){\n        asyncwhile(enabled){\n            schedule.add(crash)\n            if (enabled){\n                main()\n            }\n            schedule.remove(crash)\n            crashCount = 0\n        }\n    }\n    def stop(){\n        if (enabled){\n            onStop()\n            enabled = false\n            callback()\n            callback = null\n        }\n    }\n    def waitFor(void=>void fct){\n        callback = fct\n    }\n    def @__process_count__ __count__(){\n        t_running += enabled\n        t_total += 1\n    }\n    def abstract main()\n    def abstract onStart()\n    def abstract onStop()\n    def @stopallprocess stopall(){\n        stop()\n    }\n}\n\nstatic abstract class slow_process{\n    int enabled\n    int crashCount\n    void=>void callback\n    \n    loading reload(){\n        run()\n    }\n    def crash(){\n        exception.exception(\"Stack Overlow detect in Process. Try to increase the maxCommandChainLength\")\n        crashCount++\n        if (crashCount > 10){\n            exception.exception(\"Max Number of Stack Overflow reach. Process Killed.\")\n            enabled = 0\n        }\n        run()\n    }\n    def start(){\n        enabled:=false\n        if (!enabled){\n            enabled = true\n            onStart()\n            run()\n        }\n    }\n    def @__process_main__ run(){\n        asyncwhile(enabled,20){\n            schedule.add(crash)\n            if (enabled){\n                main()\n            }\n            schedule.remove(crash)\n            crashCount = 0\n        }\n    }\n    def stop(){\n        if (enabled){\n            onStop()\n            enabled = false\n            callback()\n            callback = null\n        }\n    }\n    def waitFor(void=>void fct){\n        callback = fct\n    }\n    def @__process_count__ __count__(){\n        t_running += enabled\n        t_total += 1\n    }\n    def abstract main()\n    def abstract onStart()\n    def abstract onStop()\n    def @stopallprocess stopall(){\n        stop()\n    }\n}\n\nstatic abstract class pprocess{\n    int enabled\n    int crashCount\n    void=>void callback\n    \n    loading reload(){\n        run()\n    }\n    def crash(){\n        exception.exception(\"Stack Overlow detect in Process. Try to increase the maxCommandChainLength\")\n        crashCount++\n        if (crashCount > 10){\n            exception.exception(\"Max Number of Stack Overflow reach. Process Killed.\")\n            enabled = 0\n        }\n        run()\n    }\n    def start(){\n        enabled:=false\n        if (!enabled){\n            enabled = true\n            onStart()\n            run()\n        }\n    }\n    def @__process_main__ run(){\n        asyncwhile(enabled){\n            schedule.add(crash)\n            if (enabled){\n                with(@a,true){\n                    main()\n                }\n            }\n            schedule.remove(crash)\n            crashCount = 0\n        }\n    }\n    def stop(){\n        if (enabled){\n            onStop()\n            enabled = false\n            callback()\n            callback = null\n        }\n    }\n    def waitFor(void=>void fct){\n        callback = fct\n    }\n    def @__process_count__ __count__(){\n        t_running += enabled\n        t_total += 1\n    }\n    def abstract main()\n    def abstract onStart()\n    def abstract onStop()\n    def @stopallprocess stopall(){\n        stop()\n    }\n}\n\nstatic abstract class cprocess{\n    int enabled\n    int count\n    int crashCount\n    void=>void callback\n    \n    loading reload(){\n        run()\n        count:=0\n    }\n    def crash(){\n        exception.exception(\"Stack Overlow detect in Process. Try to increase the maxCommandChainLength\")\n        crashCount++\n        if (crashCount > 10){\n            exception.exception(\"Max Number of Stack Overflow reach. Process Killed.\")\n            enabled = 0\n        }\n        run()\n    }\n    def start(){\n        enabled:=false\n        if (!enabled){\n            enabled = true\n            onStart()\n            run()\n        }\n        count++\n    }\n    def @__process_main__ run(){\n        asyncwhile(enabled){\n            schedule.add(crash)\n            if (enabled){\n                main()\n            }\n            schedule.remove(crash)\n            crashCount = 0\n        }\n    }\n    def stop(){\n        enabled:=false\n        if (enabled){\n            count--\n            if (count == 0){\n                onStop()\n                enabled = false\n                callback()\n                callback = null\n            }\n        }\n    }\n    def stopAll(){\n        count = 0\n        onStop()\n        enabled = false\n    }\n    def @reset reset(){\n        count = 0\n    }\n    def waitFor(void=>void fct){\n        callback = fct\n    }\n    def @__process_count__ __count__(){\n        t_running += enabled\n        t_total += 1\n    }\n    def abstract main()\n    def abstract onStart()\n    def abstract onStop()\n    def @stopallprocess stopall(){\n        while(count > 0){\n            stop()\n        }\n    }\n}\n\n","index":0},{"name":"cschedule","content":"package cschedule\n\ndef lazy add(function $func){\n    tag($func)\n    schedule.add{\n        with(@e[tag=$func],true){\n            untag($func)\n            $func()\n        }\n    }\n}\ndef lazy add(function $func, int $t){\n    tag($func)\n    schedule.add($t){\n        with(@e[tag=$func],true){\n            untag($func)\n            $func()\n        }\n    }\n}\ndef lazy add(function $func, int $t, int $unit){\n    tag($func)\n    schedule.add($t,$unit){\n        with(@e[tag=$func],true){\n            untag($func)\n            $func()\n        }\n    }\n}","index":0}],"resources":[],"TagsList":{"blocks":{},"functions":{}},"mcTagsList":{"blocks":{},"functions":{"load":{"values":["load"]},"tick":{"values":["main"]}}},"compileOrder":[],"version":{"major":1,"minor":0,"patch":0,"build":50},"compilationSetting":{"TreeMaxSize":20,"FloatPrecision":1000,"removeUselessFile":true,"offuscate":true,"randomLambdaID":false,"scoreboardValue":"tbms.value","structuresSource":"","structuresSources":{},"scoreboardConst":"tbms.const","scoreboardTmp":"tbms.tmp","tagsFolder":true,"forcedOffuscation":{},"libraryFolder":["./lib/1_17/","./lib/1_16_5/","./lib/shared/"],"MCVersion":"1.16.5","ExportAsZip":false,"packformat":7,"rppackformat":7,"CompilerCoreName":"java","Authors":"","generateMAPSFile":true,"generateREADMEFile":true,"opti_FunctionTagsReplace":true,"opti_ExportComment":false,"opti_ShowException":true,"opti_ShowDebug":true,"opti_FileCleanUp":true,"opti_LambdaCleanUp":false,"advanced_debug":false,"autoSave":true,"isLibrary":false}}