{"projectName":"math","datapackDirectory":null,"resourcesPackDirectory":null,"offuscate":true,"isLibrary":true,"description":"Made With BluePhoenix","files":[{"name":"import","content":"import standard.exception\nimport cmd.pointer","index":0},{"name":"constant","content":"package math\n\nlazy float pi(){\n\treturn(3.1415)\n}\nlazy float e(){\n\treturn(2.718)\n}","index":0},{"name":"abs","content":"package math\n\n\"\"\"\nGive sign of argument\n-1 if value smaller than 0 \n\t1 otherwise\n\"\"\"\ndef sign(float value):int{\n\tif (value >= 0){\n\t\treturn(1)\n\t}\n\tif (value < 0){\n\t\treturn(-1)\n\t}\n}\n\n\"\"\"\nGive sign of argument\n-1 if value smaller than 0 \n\t1 otherwise\n\"\"\"\ndef sign(int value):int{\n\tif (value >= 0){\n\t\treturn(1)\n\t}\n\tif (value < 0){\n\t\treturn(-1)\n\t}\n}\n\n\"\"\"\nGive magnitude of argument\nv if v > 0\n\t-v otherwise\n\"\"\"\ndef abs(float value):float{\n\tif (value >= 0){\n\t\treturn(value)\n\t}\n\tif (value < 0){\n\t\treturn(-value)\n\t}\n}\n\n\"\"\"\nGive magnitude of argument\nv if v > 0\n\t-v otherwise\n\"\"\"\ndef abs(int value):int{\n\tif (value >= 0){\n\t\treturn(value)\n\t}\n\tif (value < 0){\n\t\treturn(-value)\n\t}\n}\n\n\"\"\"\nGive a mod b the correct way\n\"\"\"\ndef mod(float a, float b):float{\n\tfloat ret = a+b\n\tret %= b\n\treturn(ret)\n}\n\n\"\"\"\nGive a mod b the correct way\n\"\"\"\ndef mod(int a, int b):int{\n\tint ret = a+b\n\tret %= b\n\treturn(ret)\n}\n\n\"\"\"\nRound float to closest value\n\"\"\"\ndef round(float value):float{\n\tvalue += 0.5\n\tvalue /= 1000\n\tvalue *= 1000\n\treturn(value)\n}\n\n\"\"\"\nRound float to lowest value\n\"\"\"\ndef floor(float value):float{\n\tvalue /= 1000\n\tvalue *= 1000\n\treturn(value)\n}\n\n\"\"\"\nRound float to upper value\n\"\"\"\ndef ceil(float value):float{\n\tvalue += 0.999\n\tvalue /= 1000\n\tvalue *= 1000\n\treturn(value)\n}","index":0},{"name":"sqrt","content":"package math\n\n\"\"\"\nreturn true if difference between x and y smaller than maxDiff\n\"\"\"\ndef isClose(float x, float y, float maxDiff = 0.01):bool{\n    float diff = x - y\n    diff = abs(diff)\n    \n    if (diff < maxDiff){\n        return(1)\n    }\n    if (diff >= maxDiff){\n        return(0)\n    }\n}\n\n\"\"\"\nGive squart root of value\n\"\"\"\ndef sqrt(float value):float{\n    if (value < 0){\n        exception.invalidArgument(\"value in math.sqrt\")\n    }\n    \n    def iterate(float guess):float{\n        float next\n        next = (value/guess)\n        next += guess\n        next /= 2\n        bool close = isClose(next, guess)\n        \n        if (close){\n            return(next)\n        }\n        if(!close){\n            return(iterate(next))\n        }\n    }\n    return(iterate(value))\n}\nfloat root(float n){\n  // Max and min are used to take into account numbers less than 1\n  float lo = math.min(1, n)\n  float hi = math.max(1, n)\n  float mid;\n\n  // Update the bounds to be off the target by a factor of 10\n  while(100 * lo * lo < n) lo *= 10;\n  while(100 * hi * hi > n) hi *= 0.1;\n  bool ret = false\n  for(int i = 0 ; i < 100 && !ret; i++){\n      mid = (lo+hi)/2;\n      if(mid*mid == n){ret = true}\n      if(mid*mid > n){hi = mid}\n      else {lo = mid}\n  }\n  return mid;\n}\n","index":0},{"name":"factorial","content":"package math\n\n\"\"\"\nreturn x!\n\"\"\"\ndef factorial(int x):int{\n\tif (x < 0){\n\t\texception.invalidArgument(\"X in math.factorial\")\n\t}\n\tint res = 1\n\n\tfor(int i = 1;i <= x;i++){\n\t\tres *= i\n\t}\n\treturn(res)\n}","index":0},{"name":"exp","content":"package math\n\n\"\"\"\nGive x^n\n\"\"\"\ndef pow(float x, int n, float m = 1):float{\n    if (n < 0){\n        exception.invalidArgument(\"n in math.pow\")\n    }\n    if (n == 0){\n        return(1)\n    }\n    if (n == 1){\n        float ret = x * m\n        return(ret)\n    }\n    if (n > 1){\n        int parity = n % 2\n        \n        if (parity == 1){\n            m *= x\n            n -= 1\n        }\n        n /= 2\n        x *= x\n        return(pow(x, n, m))\n    }\n}\n\n\"\"\"\nGive x^n\n\"\"\"\ndef pow(int x, int n, int m = 1):int{\n    if (n < 0){\n        exception.invalidArgument(\"n in math.intPow\")\n    }\n    if (n == 0){\n        return(1)\n    }\n    if (n == 1){\n        int ret = x * m\n        return(ret)\n    }\n    if (n > 1){\n        int parity = x % 2\n        \n        if (parity == 1){\n            m *= x\n            n -= 1\n        }\n        n /= 2\n        x*=x\n        return(pow(x, n, m))\n    }\n}","index":0},{"name":"trigo","content":"package math\n\n\"\"\"\nGive sin(x) with a polynom of taylor of degree deg\n\"\"\"\ndef sin(float x):float{\n    pointer.new(\"trg\")\n    float z,z1\n    with(@e[tag=trg]){\n        z = @s.x\n        @s.rot_x = x\n        at(@s){\n            /tp @s ^ ^ ^1\n        }\n        z1 = @s.x\n        z -= z1\n    }\n\n    return(z)\n}\n\n\"\"\"\nGive cos(x) with a polynom of taylor of degree deg\n\"\"\"\ndef cos(float x):float{\n    pointer.new(\"trg\")\n    float z,z1\n    with(@e[tag=trg]){\n        z = @s.z\n        @s.rot_x = x\n        at(@s){\n            /tp @s ^ ^ ^1\n        }\n        z1 = @s.z\n        z1 -= z\n    }\n\n    return(z1)\n}\n\n\"\"\"\nGive tan(x) with a polynom of taylor of degree deg\n\"\"\"\ndef tan(float x):float{\n    pointer.new(\"trg\")\n    float z1,z2,x1,x2\n    with(@e[tag=trg]){\n        z1 = @s.z\n        x1 = @s.x\n        @s.rot_x = x\n        at(@s){\n            /tp @s ^ ^ ^1\n        }\n        x2 = @s.x\n        z2 = @s.z\n        x1 -= x2\n        z2 -= z1\n    }\n\n    return(x1/z1)\n}","index":0},{"name":"trigo2","content":"package math\n\n\"\"\"\nGive arcsin(x) with a polynom of taylor of degree deg\n\"\"\"\ndef arcsin(float x):float{\n\tif (x < -1 || x > 1){\n\t\texception.invalidArgument(\"x is out of bound for arcsin\")\n\t}\n\tfloat y = 0\n\tfor(int i=0;i<5;i++){\n\t\tfloat k = (factorial(2*i) / (pow(4, i) * pow(factorial(i), 2) * (2 * i + 1))) * pow(x, 2 * i + 1)\n\t\ty+=k\n\t}\n\treturn(y)\n}\n\n\"\"\"\nGive arccos(x) with a polynom of taylor of degree deg\n\"\"\"\ndef arccos(float x):float{\n\treturn(pi / 2 - arcsin(x))\n}\n\n\"\"\"\nGive arctan(x) with a polynom of taylor of degree deg\n\"\"\"\ndef arctan(float x):float{\n\tfloat y = 0\n\tfor(float i=0;i<15;i++){\n\t\tfloat k = (pow(-1, i)/(2*i+1))*pow(x, 2*i+1)\n\t\ty+=k\n\t}\n\treturn(y)\n}","index":0},{"name":"trigo3","content":"package math\n\n\"\"\"\nGive sinh(x) with a polynom of taylor of degree deg\n\"\"\"\ndef sinh(float x):float{\n\tfloat y = 0\n\tfor(float i=0;i<15;i++){\n\t\tfloat k = pow(x, 2*i+1)/factorial(2*i+1)\n\t\ty+=k\n\t}\n\treturn(y)\n}\n\n\"\"\"\nGive cosh(x) with a polynom of taylor of degree deg\n\"\"\"\ndef cosh(float x):float{\n\tfloat y = 0\n\tfor(float i=0;i<15;i++){\n\t\tfloat k = pow(x, 2*i)/factorial(2*i)\n\t\ty+=k\n\t}\n\treturn(y)\n}","index":0},{"name":"bound","content":"package math\n\n\"\"\"\nGive max between a and b\n\"\"\"\ndef max(int a, int b):int{\n\tif (a < b){\n\t\treturn(b)\n\t}\n\tif (a >= b){\n\t\treturn(a)\n\t}\n}\n\n\"\"\"\nGive max between a and b\n\"\"\"\ndef max(float a, float b):float{\n\tif (a < b){\n\t\treturn(b)\n\t}\n\tif (a >= b){\n\t\treturn(a)\n\t}\n}\n\n\"\"\"\nGive min between a and b\n\"\"\"\ndef min(int a, int b):int{\n\tif (a < b){\n\t\treturn(a)\n\t}\n\tif (a >= b){\n\t\treturn(b)\n\t}\n}\n\n\"\"\"\nGive min between a and b\n\"\"\"\ndef min(float a, float b):float{\n\tif (a < b){\n\t\treturn(a)\n\t}\n\tif (a >= b){\n\t\treturn(b)\n\t}\n}\n\n\"\"\"\nGive bound a between b and c\n\"\"\"\ndef bound(int a, int b, int c):int{\n\treturn(math.max(math.min(a, b),c))\n}\n\n\"\"\"\nGive bound a between b and c\n\"\"\"\ndef bound(float a, float b, float c):float{\n\treturn(math.max(math.min(a, b),c))\n}","index":0},{"name":"sort","content":"package math\n\ndef sorted(int a, int b):int,int{\n    if (a > b){\n        return(b, a)\n    }\n    if (a <= b){\n        return(a, b)\n    }\n}\n\ndef sorted(float a, float b):float,float{\n    if (a > b){\n        return(b, a)\n    }\n    if (a <= b){\n        return(a, b)\n    }\n}\n\ndef lazy swap(int $a, int $b){\n    int c = $a\n    $a = $b\n    $b = c\n}\n\ndef lerp(float a, float b, float w):float{\n    return(a*(1-w) + b*w)\n}\n\nfloat smoothlerp(float a0, float a1, float w){\n    w = w*w*(3-2*w)\n    float value = (1.0 - w)*a0 + w*a1\n    return value\n}","index":0}],"resources":[],"TagsList":{"blocks":{},"functions":{}},"mcTagsList":{"blocks":{},"functions":{"load":{"values":[]},"tick":{"values":[]}}},"compileOrder":[],"version":{"major":1,"minor":0,"patch":0,"build":32},"compilationSetting":{"TreeMaxSize":20,"FloatPrecision":1000,"removeUselessFile":true,"offuscate":true,"scoreboardValue":"tbms.value","scoreboardConst":"tbms.const","scoreboardTmp":"tbms.tmp","tagsFolder":true,"forcedOffuscation":{},"libraryFolder":["./lib/1_16_5/","./lib/shared/"],"MCVersion":"1.17","ExportAsZip":false,"packformat":6,"rppackformat":7,"CompilerCoreName":"java","Authors":"","generateMAPSFile":true,"generateREADMEFile":true,"opti_FunctionTagsReplace":true,"opti_ExportComment":false,"opti_ShowException":true,"opti_ShowDebug":true,"opti_FileCleanUp":true,"advanced_debug":false,"isLibrary":false}}