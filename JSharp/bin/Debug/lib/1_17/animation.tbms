{"projectName":"animation","datapackDirectory":null,"resourcesPackDirectory":null,"offuscate":true,"isLibrary":true,"description":"Made With BluePhoenix","files":[{"name":"import","content":"import standard.java\nimport standard.object\nimport math\nimport math.vector\nimport entity.armor_stand","index":0},{"name":"load","content":"package main","index":0},{"name":"main","content":"package main\n","index":0},{"name":"position","content":"package animation\n\ndef lerpPosition(float time, float timeMax,float x1, float y1, float z1,float u1, float v1, float x2, float y2, float z2, float u2, float v2, void=>void onEnd = null){\n    float l = math.max(math.min(time/timeMax,1.0),0.0)\n    float x = l*(x2)+(1-l)*(x1)\n    float y = l*(y2)+(1-l)*(y1)\n    float z = l*(z2)+(1-l)*(z1)\n    float u = l*(u2)+(1-l)*(u1)\n    float v = l*(v2)+(1-l)*(v1)\n\n    if (@s[type=player]){\n        /summon marker ~ ~ ~ {Tags:[\"anim_trg\"]}\n        with(@e[tag=anim_trg]){\n            @s.x = x\n            @s.y = y\n            @s.z = z\n            @s.rot_x = u\n            @s.rot_y = v\n        }\n        \n        /execute at @e[tag=anim_trg,limit=1] rotated as @e[tag=anim_trg,limit=1] run tp @s ~ ~ ~ ~ ~\n        kill(@e[tag=anim_trg])\n    }\n    if (@s[type=!player]){\n        @s.x = x\n        @s.y = y\n        @s.z = z\n        @s.rot_x = u\n        @s.rot_y = v\n    }\n    if (l == 1){\n        onEnd()\n    }\n}\n\n    def bezier(float time, float timeMax forgenerate($i,1,3){,float x$i, float y$i, float z$i,float u$i, float v$i}, void=>void onEnd = null){\n    float l = math.max(math.min(time/timeMax,1.0),0.0)\n    float l_ = (1-l)\n    \n    float t1 = l*l\n    float t2 = l*l_*2\n    float t3 = (1-t1)-t2\n    \n    float x = t1*(x3)+t2*(x2)+t3*(x1)\n    float y = t1*(y3)+t2*(y2)+t3*(y1)\n    float z = t1*(z3)+t2*(z2)+t3*(z1)\n    float u = t1*(u3)+t2*(u2)+t3*(u1)\n    float v = t1*(v3)+t2*(v2)+t3*(v1)\n    if (@s[type=player]){\n        /summon marker ~ ~ ~ {Tags:[\"anim_trg\"]}\n        with(@e[tag=anim_trg]){\n            @s.x = x\n            @s.y = y\n            @s.z = z\n            @s.rot_x = u\n            @s.rot_y = v\n        }\n        /execute at @e[tag=anim_trg,limit=1] rotated as @e[tag=anim_trg,limit=1] run tp @s ~ ~ ~ ~ ~\n        kill(@e[tag=anim_trg])\n    }\n    if (@s[type=!player]){\n        @s.x = x\n        @s.y = y\n        @s.z = z\n        @s.rot_x = u\n        @s.rot_y = v\n    }\n    if (l == 1){\n        onEnd()\n    }\n}\ndef bezierGlobal(float time, float timeMax forgenerate($i,1,3){,float x$i, float y$i, float z$i,float u$i, float v$i}, void=>void onEnd = null){\n    float l = math.max(math.min(time/timeMax,1.0),0.0)\n    float l_ = (1-l)\n    \n    float t1 = l*l\n    float t2 = 2*l*l_\n    float t3 = (1-t1)-t2\n    \n    float x = t1*(x3)+t2*(x2)+t3*(x1)\n    float y = t1*(y3)+t2*(y2)+t3*(y1)\n    float z = t1*(z3)+t2*(z2)+t3*(z1)\n    float u = t1*(u3)+t2*(u2)+t3*(u1)\n    float v = t1*(v3)+t2*(v2)+t3*(v1)\n    /summon marker ~ ~ ~ {Tags:[\"anim_trg\"]}\n    with(@e[tag=anim_trg]){\n        @s.x = x\n        @s.y = y\n        @s.z = z\n        @s.rot_x = u\n        @s.rot_y = v\n    }\n    /execute at @e[tag=anim_trg,limit=1] rotated as @e[tag=anim_trg,limit=1] run tp @a ~ ~ ~ ~ ~\n    kill(@e[tag=anim_trg])\n\n    \n    if (l == 1){\n        onEnd()\n    }\n}\ndef lazy bezierTrail(int step forgenerate($i,1,3){,float x$i, float y$i, float z$i,float u$i, float v$i}){\n    kill(@e[tag=bez_trg])\n    /summon marker ~ ~ ~ {Tags:[\"bez_trg\"]}\n    with(@e[tag=bez_trg]){\n        for(int i = 0;i < maxTime;i+=step){\n            animation.bezier(i,maxTime forgenerate($i,1,3){,x$i, y$i, z$i,u$i, v$i})\n            at(@s){\n                /particle minecraft:dust 1 1 1 1 ~ ~ ~ 0 0 0 0 1\n            }\n        }\n    }\n}\n","index":0},{"name":"models","content":"package animation\n\n\ndef lazy models(int $time, int $model, params $values){\n    switch(($time)%$values.count){\n        forgenerate($i,$values){\n            case($i.index){\n                armor_stand.setModel($model,$i)\n            }\n        }\n    }\n}\n\ndef lazy walk(int $time, int $model, int $idle, int $i1, int $i2, int $i3, int $i4){\n    models($time,$model,$idle,$i1,$i2,$i1,$idle,$i3,$i4,$i3)\n}","index":0},{"name":"rotation","content":"package animation\n\ndef lazy lookAt(int $entity){\n    at(@s){\n        facing($entity){\n            /tp @s ~ ~ ~ ~ ~\n        }\n    }\n}\n\ndef spin(int time, int speed){\n    int angle = time*speed\n    @s.rot_x = angle\n}\n\ndef spin(int time, int speed, int start){\n    int angle = time*speed + start\n    @s.rot_x = angle\n}","index":0},{"name":"animated_object","content":"package animation\n\nclass animatedObject extends object_armor_stand{\n    vector3 position\n    vector3 velocity\n    vector3 acceleration\n    vector2 angle\n    vector2 angularVelocity\n    vector2 angularAcceleration\n    \n    int animationTime\n    int=>void animation\n    bool hasCollision\n    \n    public void __init__(bool collision = true){\n        position = vector3.position()\n        velocity = vector3.zeros()\n        acceleration = vector3.zeros()\n        hasCollision = collision\n        data.set({Marker:1})\n    }\n    public void setAnimation(int=>void action){\n        animationTime = 0\n        animation = action\n    }\n    \n    public @animatedObjectTick void main(){\n        vector3 previousPosition = position\n        velocity += acceleration\n        \n        if (hasCollision){\n            at(@s){\n                if (!block(~ ~-0.1 ~ air) && velocity.y < 0){\n                    velocity.y = 0\n                    position.y = math.round(position.y)\n                    vector.setPosition(position)\n                    at(@s){\n                        if (!block(~ ~0.1 ~ air)){\n                            /tp @s ~ ~1 ~\n                            position.y++\n                        }\n                    }\n                }\n            }\n            at(@s){\n                if (!block(~ ~2.1 ~ air) && velocity.y > 0){\n                    velocity.y = 0\n                }\n                if (!block(~-1 ~0.1 ~ air) && velocity.x < 0){\n                    velocity.x = 0\n                }\n                if (!block(~1 ~0.1 ~ air) && velocity.x > 0){\n                    velocity.x = 0\n                }\n                if (!block(~ ~0.1 ~-1 air) && velocity.z < 0){\n                    velocity.z = 0\n                }\n                if (!block(~ ~0.1 ~1 air) && velocity.z > 0){\n                    velocity.z = 0\n                }\n            }\n        }\n        \n        position += velocity\n        vector.setPosition(position)\n        \n        angularVelocity += angularAcceleration\n        angle += angularVelocity\n        vector.setRotation(angle)\n        \n        animation(animationTime)\n        animationTime ++\n    }\n    public void lazy lookAt(entity $e){\n        at(@s){\n            facing($e){\n                /tp @s ~ ~ ~ ~ ~\n            }\n        }\n        angle = vector2.rotation()\n    }\n    public void setPosition(vector3 newPosition){\n        position = newPosition\n    }\n    public void setPosition(float x, float y, float z){\n        position = x,y,z\n    }\n    public void setVelocity(vector3 newVelocity){\n        velocity = newVelocity\n    }\n    public void setVelocity(float x, float y, float z){\n        velocity = x,y,z\n    }\n    public void setAcceleration(vector3 newacceleration){\n        acceleration = newacceleration\n    }\n    public void setAcceleration(float x, float y, float z){\n        acceleration = x,y,z\n    }\n    public void setRotation(vector2 newRotation){\n        angle = newRotation\n    }\n    public void setRotation(float x, float y){\n        angle = x,y\n    }\n    public void setRotationSpeed(vector2 newVelocity){\n        angularVelocity = newVelocity\n    }\n    public void setRotationSpeed(float x, float y){\n        angularVelocity = x,y\n    }\n    public void setRotationAcceleration(vector2 newacceleration){\n        angularAcceleration = newacceleration\n    }\n    public void setRotationAcceleration(float x, float y){\n        angularAcceleration = x,y\n    }\n}","index":0},{"name":"travelling","content":"package animation\n\ndef lazy travelling(int $indexVar,int $timeVar, int $speed, function $onEnd, params $value){\n    def end(){\n        $indexVar ++\n        $timeVar = 0\n        if ($indexVar == $value.count){\n            $onEnd()\n        }\n    }\n    forgenerate($c,$value){\n        if($indexVar == $c.index){\n            if ($c.count == 6){\n                /tp @s $c.0 $c.1 $c.2 $c.3 $c.4\n                if ($timeVar > $c.5){\n                    end()\n                }\n            }\n            if ($c.count == 10){\n                int $distance = $eval(((($c.0)-($c.5))^2+(($c.1)-($c.6))^2+(($c.2)-($c.7))^2)^0.5)eval$\n                int $time = $eval($distance / $speed)\n                \n                animation.lazylerpPosition($timeVar,$time,\n                    $c.0,$c.1,$c.2,$c.3,$c.4,\n                    $c.5,$c.6,$c.7,$c.8,$c.9,\n                    end)\n            }\n            if ($c.count == 15){\n                int $distance1 = $eval(((($c.0)-($c.5))^2+(($c.1)-($c.6))^2+(($c.2)-($c.7))^2)^0.5)eval$\n                int $distance2 = $eval(((($c.5)-($c.10))^2+(($c.6)-($c.11))^2+(($c.7)-($c.12))^2)^0.5)eval$\n                int $distance3 = $eval(((($c.0)-($c.10))^2+(($c.1)-($c.11))^2+(($c.2)-($c.12))^2)^0.5)eval$\n                int $distance = $eval(($distance1+$distance2+$distance3)/2)eval$\n                int $time = $eval($distance / $speed)\n                \n                animation.lazybezier($timeVar,$time,\n                    $c.0,$c.1,$c.2,$c.3,$c.4,\n                    $c.5,$c.6,$c.7,$c.8,$c.9,\n                    $c.10,$c.11,$c.12,$c.13,$c.14,\n                    end)\n            }\n            require $c.count <= 15\n            require $c.count >= 6\n        }\n    }\n}\ndef lazy travellingPlayer(int $indexVar,int $timeVar, int $speed, function $onEnd, params $value){\n    armor_stand camera\n    def end(){\n        $indexVar ++\n        $timeVar = 0\n        \n        if ($indexVar == $value.count){\n            camera = null\n            $onEnd()\n        }\n    }\n    \n    forgenerate($c,$value){\n        if($indexVar == $c.index){\n            if (camera == null){\n                positioned($c.0 $c.1 $c.2){\n                    camera = new armor_stand()\n                    camera.setdata({NoGravity:1,Invisible:1,Rotation:[$c.3f,$c.4f]})\n                }\n            }\n            camera.tag(travel_trg)\n            if ($c.count == 6){\n                camera.execute(){\n                    /tp @s $c.0 $c.1 $c.2 $c.3 $c.4\n                }\n                if ($timeVar > $c.5){\n                    end()\n                }\n            }\n            if ($c.count == 10){\n                int $distance = $eval(((($c.0)-($c.5))^2+(($c.1)-($c.6))^2+(($c.2)-($c.7))^2)^0.5)eval$\n                int $time = $eval($distance / $speed)\n                \n                animation.lazylerpPositionPlayer($timeVar,$time,\n                    $c.0,$c.1,$c.2,$c.3,$c.4,\n                    $c.5,$c.6,$c.7,$c.8,$c.9,\n                    end)\n            }\n            if ($c.count == 15){\n                int $distance1 = $eval(((($c.0)-($c.5))^2+(($c.1)-($c.6))^2+(($c.2)-($c.7))^2)^0.5)eval$\n                int $distance2 = $eval(((($c.5)-($c.10))^2+(($c.6)-($c.11))^2+(($c.7)-($c.12))^2)^0.5)eval$\n                int $distance3 = $eval(((($c.0)-($c.10))^2+(($c.1)-($c.11))^2+(($c.2)-($c.12))^2)^0.5)eval$\n                int $distance = $eval(($distance1+$distance2+$distance3)/2)eval$\n                int $time = $eval($distance / $speed)\n                \n                animation.lazybezierPlayer($timeVar,$time,\n                    $c.0,$c.1,$c.2,$c.3,$c.4,\n                    $c.5,$c.6,$c.7,$c.8,$c.9,\n                    $c.10,$c.11,$c.12,$c.13,$c.14,\n                    end)\n            }\n            camera.untag(travel_trg)\n            require $c.count <= 15\n            require $c.count >= 6\n        }\n    }\n}\n\ndef lazy travellingTime(int $indexVar,int $timeVar, params $value){\n    def end(){\n        $indexVar ++\n        $timeVar = 0\n    }\n    forgenerate($c,$value){\n        if($indexVar == $c.index){\n            if ($c.count == 11){\n                animation.lazylerpPosition($timeVar,$c.0\n                    $c.1,$c.2,$c.3,$c.4,$c.5,\n                    $c.6,$c.7,$c.8,$c.9,$c.10,\n                    end)\n            }\n            if ($c.count == 16){\n                animation.lazybezier($timeVar,$c.0,\n                    $c.1,$c.2,$c.3,$c.4,$c.5,\n                    $c.6,$c.7,$c.8,$c.9,$c.10,\n                    $c.11,$c.12,$c.13,$c.14,$c.15\n                    ,end)\n            }\n            require $c.count <= 16\n            require $c.count >= 11\n        }\n    }\n}","index":0},{"name":"smartposition","content":"package animation\n\ndef lazy lazylerpPosition(float time, float timeMax,float x1, float y1, float z1,float u1, float v1, float x2, float y2, float z2, float u2, float v2, void=>void $onEnd){\n    float l = math.max(math.min(time/timeMax,1.0),0.0)\n    float l_ = (1-l)\n    \n    float x = l*(x2)+l_*(x1)\n    float y = l*(y2)+l_*(y1)\n    float z = l*(z2)+l_*(z1)\n    float u = l*(u2)+l_*(u1)\n    float v = l*(v2)+l_*(v1)\n    \n    if (@s[type=player]){\n        /summon marker ~ ~ ~ {Tags:[\"anim_trg\"]}\n        with(@e[tag=anim_trg]){\n            @s.x = x\n            @s.y = y\n            @s.z = z\n            @s.rot_x = u\n            @s.rot_y = v\n        }\n        \n        /execute at @e[tag=anim_trg,limit=1] rotated as @e[tag=anim_trg,limit=1] run tp @s ~ ~ ~ ~ ~\n        kill(@e[tag=anim_trg])\n    }\n    if (@s[type=!player]){\n        @s.x = x\n        @s.y = y\n        @s.z = z\n        @s.rot_x = u\n        @s.rot_y = v\n    }\n    \n    if (l >= 1){\n        $onEnd()\n    }\n}\n\n    def lazy lazybezier(float time, float timeMax forgenerate($i,1,3){,float x$i, float y$i, float z$i,float u$i, float v$i}, void=>void $onEnd){\n    float l = math.max(math.min(time/timeMax,1.0),0.0)\n    float l_ = (1-l)\n    \n    float t1 = l*l\n    float t2 = l*l_*2\n    float t3 = (1-t1)-t2\n    \n    float x = t1*(x3)+t2*(x2)+t3*(x1)\n    float y = t1*(y3)+t2*(y2)+t3*(y1)\n    float z = t1*(z3)+t2*(z2)+t3*(z1)\n    float u = t1*(u3)+t2*(u2)+t3*(u1)\n    float v = t1*(v3)+t2*(v2)+t3*(v1)\n    \n    if (@s[type=player]){\n        /summon marker ~ ~ ~ {Tags:[\"anim_trg\"]}\n        with(@e[tag=anim_trg]){\n            @s.x = x\n            @s.y = y\n            @s.z = z\n            @s.rot_x = u\n            @s.rot_y = v\n        }\n        /execute at @e[tag=anim_trg,limit=1] rotated as @e[tag=anim_trg,limit=1] run tp @s ~ ~ ~ ~ ~\n        kill(@e[tag=anim_trg])\n    }\n    if (@s[type=!player]){\n        @s.x = x\n        @s.y = y\n        @s.z = z\n        @s.rot_x = u\n        @s.rot_y = v\n    }\n    if (l >= 1){\n        $onEnd()\n    }\n}","index":0},{"name":"supersmartposition","content":"package animation\n\ndef lazy lazylerpPositionPlayer(float time, float timeMax,float x1, float y1, float z1,float u1, float v1, float x2, float y2, float z2, float u2, float v2, void=>void $onEnd){\n    float l = math.max(math.min(time/timeMax,1.0),0.0)\n    float l_ = (1-l)\n    \n    float x = l*(x2)+l_*(x1)\n    float y = l*(y2)+l_*(y1)\n    float z = l*(z2)+l_*(z1)\n    float u = l*(u2)+l_*(u1)\n    float v = l*(v2)+l_*(v1)\n    \n    with(@e[tag=travel_trg]){\n        @s.x = x\n        @s.y = y\n        @s.z = z\n        @s.rot_x = u\n        @s.rot_y = v\n    }\n    \n    /spectate @e[tag=travel_trg,limit=1]\n    \n    if (l >= 1){\n        $onEnd()\n    }\n}\n\n    def lazy lazybezierPlayer(float time, float timeMax forgenerate($i,1,3){,float x$i, float y$i, float z$i,float u$i, float v$i}, void=>void $onEnd){\n    float l = math.max(math.min(time/timeMax,1.0),0.0)\n    float l_ = (1-l)\n    \n    float t1 = l*l\n    float t2 = l*l_*2\n    float t3 = (1-t1)-t2\n    \n    float x = t1*(x3)+t2*(x2)+t3*(x1)\n    float y = t1*(y3)+t2*(y2)+t3*(y1)\n    float z = t1*(z3)+t2*(z2)+t3*(z1)\n    float u = t1*(u3)+t2*(u2)+t3*(u1)\n    float v = t1*(v3)+t2*(v2)+t3*(v1)\n    \n    \n    with(@e[tag=travel_trg]){\n        @s.x = x\n        @s.y = y\n        @s.z = z\n        @s.rot_x = u\n        @s.rot_y = v\n    }\n    /spectate @e[tag=travel_trg,limit=1]\n    \n    if (l >= 1){\n        $onEnd()\n    }\n}","index":0}],"resources":[],"TagsList":{"blocks":{},"functions":{}},"mcTagsList":{"blocks":{},"functions":{"load":{"values":["load"]},"tick":{"values":["main"]}}},"compileOrder":[],"version":{"major":1,"minor":0,"patch":0,"build":63},"compilationSetting":{"TreeMaxSize":20,"FloatPrecision":1000,"removeUselessFile":true,"offuscate":true,"scoreboardValue":"tbms.value","scoreboardConst":"tbms.const","scoreboardTmp":"tbms.tmp","tagsFolder":true,"forcedOffuscation":{},"libraryFolder":["./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/"],"MCVersion":"1.16.5","ExportAsZip":false,"packformat":6,"rppackformat":7,"CompilerCoreName":"java","Authors":"","generateMAPSFile":true,"generateREADMEFile":true,"opti_FunctionTagsReplace":true,"opti_ExportComment":false,"opti_ShowException":true,"opti_ShowDebug":true,"advanced_debug":false,"isLibrary":false}}