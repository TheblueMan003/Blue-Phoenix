{"projectName":"animation","datapackDirectory":null,"resourcesPackDirectory":null,"offuscate":false,"isLibrary":false,"description":"Made With BluePhoenix","files":[{"name":"import","content":"import standard.java\nimport standard.object\nimport math\nimport math.vector\nimport entity.armor_stand","index":0},{"name":"load","content":"package main","index":0},{"name":"main","content":"package main\n","index":0},{"name":"position","content":"package animation\n\ndef lerpPosition(float time, float timeMax,float x1, float y1, float z1,float u1, float v1, float x2, float y2, float z2, float u2, float v2, void=>void onEnd = null){\n\tfloat l = math.max(math.min(time,timeMax),0.0)/(timeMax)\n\tfloat x = l*(x2)+(1-l)*(x1)\n\tfloat y = l*(y2)+(1-l)*(y1)\n\tfloat z = l*(z2)+(1-l)*(z1)\n\tfloat u = l*(u2)+(1-l)*(u1)\n\tfloat v = l*(v2)+(1-l)*(v1)\n\n\tif (@s[type=player]){\n\t\t/summon marker ~ ~ ~ {Tags:[\"anim_trg\"]}\n\t\twith(@e[tag=anim_trg]){\n\t\t\t@s.x = x\n\t\t\t@s.y = y\n\t\t\t@s.z = z\n\t\t\t@s.rot_x = u\n\t\t\t@s.rot_y = v\n\t\t}\n\t\t\n\t\t/execute at @e[tag=anim_trg,limit=1] rotated as @e[tag=anim_trg,limit=1] run tp @s ~ ~ ~ ~ ~\n\t\tkill(@e[tag=anim_trg])\n\t}\n\tif (@s[type=!player]){\n\t\t@s.x = x\n\t\t@s.y = y\n\t\t@s.z = z\n\t\t@s.rot_x = u\n\t\t@s.rot_y = v\n\t}\n\tif (l == 1){\n\t\tonEnd()\n\t}\n}\n\n\tdef bezier(float time, float timeMax forgenerate($i,1,3){,float x$i, float y$i, float z$i,float u$i, float v$i}, void=>void onEnd = null){\n\tfloat l = math.max(math.min(time,timeMax),0.0)/timeMax\n\tfloat l_ = (1-l)\n\t\n\tfloat t1 = l*l\n\tfloat t2 = 2*l*l_\n\tfloat t3 = 1-t1-t2\n\t\n\tfloat x = t1*(x3)+t2*(x2)+t3*(x1)\n\tfloat y = t1*(y3)+t2*(y2)+t3*(y1)\n\tfloat z = t1*(z3)+t2*(z2)+t3*(z1)\n\tfloat u = t1*(u3)+t2*(u2)+t3*(u1)\n\tfloat v = t1*(v3)+t2*(v2)+t3*(v1)\n\tif (@s[type=player]){\n\t\t/summon marker ~ ~ ~ {Tags:[\"anim_trg\"]}\n\t\twith(@e[tag=anim_trg]){\n\t\t\t@s.x = x\n\t\t\t@s.y = y\n\t\t\t@s.z = z\n\t\t\t@s.rot_x = u\n\t\t\t@s.rot_y = v\n\t\t}\n\t\t/execute at @e[tag=anim_trg,limit=1] rotated as @e[tag=anim_trg,limit=1] run tp @s ~ ~ ~ ~ ~\n\t\tkill(@e[tag=anim_trg])\n\t}\n\tif (@s[type=!player]){\n\t\t@s.x = x\n\t\t@s.y = y\n\t\t@s.z = z\n\t\t@s.rot_x = u\n\t\t@s.rot_y = v\n\t}\n\tif (l == 1){\n\t\tonEnd()\n\t}\n}\ndef bezierGlobal(float time, float timeMax forgenerate($i,1,3){,float x$i, float y$i, float z$i,float u$i, float v$i}, void=>void onEnd = null){\n\tfloat l = math.max(math.min(time,timeMax),0)/timeMax\n\tfloat l_ = (1-l)\n\t\n\tfloat t1 = l*l\n\tfloat t2 = 2*l*l_\n\tfloat t3 = 1-t1-t2\n\t\n\tfloat x = t1*(x3)+t2*(x2)+t3*(x1)\n\tfloat y = t1*(y3)+t2*(y2)+t3*(y1)\n\tfloat z = t1*(z3)+t2*(z2)+t3*(z1)\n\tfloat u = t1*(u3)+t2*(u2)+t3*(u1)\n\tfloat v = t1*(v3)+t2*(v2)+t3*(v1)\n\t/summon marker ~ ~ ~ {Tags:[\"anim_trg\"]}\n\twith(@e[tag=anim_trg]){\n\t\t@s.x = x\n\t\t@s.y = y\n\t\t@s.z = z\n\t\t@s.rot_x = u\n\t\t@s.rot_y = v\n\t}\n\t/execute at @e[tag=anim_trg,limit=1] rotated as @e[tag=anim_trg,limit=1] run tp @a ~ ~ ~ ~ ~\n\tkill(@e[tag=anim_trg])\n\n\t\n\tif (l == 1){\n\t\tonEnd()\n\t}\n}\ndef lazy bezierTrail(int step forgenerate($i,1,3){,float x$i, float y$i, float z$i,float u$i, float v$i}){\n\tkill(@e[tag=bez_trg])\n\t/summon marker ~ ~ ~ {Tags:[\"bez_trg\"]}\n\twith(@e[tag=bez_trg]){\n\t\tfor(int i = 0;i < maxTime;i+=step){\n\t\t\tanimation.bezier(i,maxTime forgenerate($i,1,3){,x$i, y$i, z$i,u$i, v$i})\n\t\t\tat(@s){\n\t\t\t\t/particle minecraft:dust 1 1 1 1 ~ ~ ~ 0 0 0 0 1\n\t\t\t}\n\t\t}\n\t}\n}\n","index":0},{"name":"models","content":"package animation\n\n\ndef lazy models(int $time, int $model, int $i0, int $i1){\n\tswitch(($time)%2){\n\t\tforgenerate($i,0,1){\n\t\t\t$i -> armor_stand.setModel($model,$i0)\n\t\t}\n\t}\n}\n\ndef lazy models(int $time, int $model, int $i0, int $i1, int $i2){\n\tswitch(($time)%3){\n\t\tforgenerate($i,0,2){\n\t\t\t$i -> armor_stand.setModel($model,$i0)\n\t\t}\n\t}\n}\n\ndef lazy models(int $time, int $model, int $i0, int $i1, int $i2, int $i3){\n\tswitch(($time)%4){\n\t\tforgenerate($i,0,3){\n\t\t\t$i -> armor_stand.setModel($model,$i0)\n\t\t}\n\t}\n}\n\ndef lazy models(int $time, int $model, int $i0, int $i1, int $i2, int $i3, int $i4){\n\tswitch(($time)%5){\n\t\tforgenerate($i,0,4){\n\t\t\t$i -> armor_stand.setModel($model,$i0)\n\t\t}\n\t}\n}\n\ndef lazy models(int $time, int $model, int $i0, int $i1, int $i2, int $i3, int $i4, int $i5){\n\tswitch(($time)%6){\n\t\tforgenerate($i,0,5){\n\t\t\t$i -> armor_stand.setModel($model,$i0)\n\t\t}\n\t}\n}\n\ndef lazy models(int $time, int $model, int $i0, int $i1, int $i2, int $i3, int $i4, int $i5, int $i6){\n\tswitch(($time)%7){\n\t\tforgenerate($i,0,6){\n\t\t\t$i -> armor_stand.setModel($model,$i0)\n\t\t}\n\t}\n}\n\ndef lazy models(int $time, int $model, int $i0, int $i1, int $i2, int $i3, int $i4, int $i5, int $i6, int $i7){\n\tswitch(($time)%8){\n\t\tforgenerate($i,0,7){\n\t\t\t$i -> armor_stand.setModel($model,$i0)\n\t\t}\n\t}\n}\n\ndef lazy models(int $time, int $model, int $i0, int $i1, int $i2, int $i3, int $i4, int $i5, int $i6, int $i7, int $i8){\n\tswitch(($time)%9){\n\t\tforgenerate($i,0,8){\n\t\t\t$i -> armor_stand.setModel($model,$i0)\n\t\t}\n\t}\n}\n\ndef lazy models(int $time, int $model, int $i0, int $i1, int $i2, int $i3, int $i4, int $i5, int $i6, int $i7, int $i8, int $i9){\n\tswitch(($time)%10){\n\t\tforgenerate($i,0,9){\n\t\t\t$i -> armor_stand.setModel($model,$i0)\n\t\t}\n\t}\n}\n\ndef lazy walk(int $time, int $model, int $idle, int $i1, int $i2, int $i3, int $i4){\n\tmodels($time,$model,$idle,$i1,$i2,$i1,$idle,$i3,$i4,$i3)\n}","index":0},{"name":"rotation","content":"package animation\n\ndef lazy lookAt(int $entity){\n\tat(@s){\n\t\tfacing($entity){\n\t\t\t/tp @s ~ ~ ~ ~ ~\n\t\t}\n\t}\n}\n\ndef spin(int time, int speed){\n\tint angle = time*speed\n\t@s.rot_x = angle\n}\n\ndef spin(int time, int speed, int start){\n\tint angle = time*speed + start\n\t@s.rot_x = angle\n}","index":0},{"name":"animated_object","content":"package animation\n\nclass animatedObject extends object_armor_stand{\n\tvector3 position\n\tvector3 velocity\n\tvector3 acceleration\n\tvector2 angle\n\tvector2 angularVelocity\n\tvector2 angularAcceleration\n\t\n\tint animationTime\n\tint=>void animation\n\tbool hasCollision\n\t\n\tpublic void __init__(bool collision = true){\n\t\tposition = vector3.position()\n\t\tvelocity = vector3.zeros()\n\t\tacceleration = vector3.zeros()\n\t\thasCollision = collision\n\t\tdata.set({Marker:1})\n\t}\n\tpublic void setAnimation(int=>void action){\n\t\tanimationTime = 0\n\t\tanimation = action\n\t}\n\t\n\tpublic @animatedObjectTick void main(){\n\t\tvector3 previousPosition = position\n\t\tvelocity += acceleration\n\t\t\n\t\tif (hasCollision){\n\t\t\tat(@s){\n\t\t\t\tif (!block(~ ~-0.1 ~ air) && velocity.y < 0){\n\t\t\t\t\tvelocity.y = 0\n\t\t\t\t\tposition.y = math.round(position.y)\n\t\t\t\t\tvector.setPosition(position)\n\t\t\t\t\tat(@s){\n\t\t\t\t\t\tif (!block(~ ~0.1 ~ air)){\n\t\t\t\t\t\t\t/tp @s ~ ~1 ~\n\t\t\t\t\t\t\tposition.y++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tat(@s){\n\t\t\t\tif (!block(~ ~2.1 ~ air) && velocity.y > 0){\n\t\t\t\t\tvelocity.y = 0\n\t\t\t\t}\n\t\t\t\tif (!block(~-1 ~0.1 ~ air) && velocity.x < 0){\n\t\t\t\t\tvelocity.x = 0\n\t\t\t\t}\n\t\t\t\tif (!block(~1 ~0.1 ~ air) && velocity.x > 0){\n\t\t\t\t\tvelocity.x = 0\n\t\t\t\t}\n\t\t\t\tif (!block(~ ~0.1 ~-1 air) && velocity.z < 0){\n\t\t\t\t\tvelocity.z = 0\n\t\t\t\t}\n\t\t\t\tif (!block(~ ~0.1 ~1 air) && velocity.z > 0){\n\t\t\t\t\tvelocity.z = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tposition += velocity\n\t\tvector.setPosition(position)\n\t\t\n\t\tangularVelocity += angularAcceleration\n\t\tangle += angularVelocity\n\t\tvector.setRotation(angle)\n\t\t\n\t\tanimation(animationTime)\n\t\tanimationTime ++\n\t}\n\tpublic void lazy lookAt(entity $e){\n\t\tat(@s){\n\t\t\tfacing($e){\n\t\t\t\t/tp @s ~ ~ ~ ~ ~\n\t\t\t}\n\t\t}\n\t\tangle = vector2.rotation()\n\t}\n\tpublic void setPosition(vector3 newPosition){\n\t\tposition = newPosition\n\t}\n\tpublic void setPosition(float x, float y, float z){\n\t\tposition = x,y,z\n\t}\n\tpublic void setVelocity(vector3 newVelocity){\n\t\tvelocity = newVelocity\n\t}\n\tpublic void setVelocity(float x, float y, float z){\n\t\tvelocity = x,y,z\n\t}\n\tpublic void setAcceleration(vector3 newacceleration){\n\t\tacceleration = newacceleration\n\t}\n\tpublic void setAcceleration(float x, float y, float z){\n\t\tacceleration = x,y,z\n\t}\n\tpublic void setRotation(vector2 newRotation){\n\t\tangle = newRotation\n\t}\n\tpublic void setRotation(float x, float y){\n\t\tangle = x,y\n\t}\n\tpublic void setRotationSpeed(vector2 newVelocity){\n\t\tangularVelocity = newVelocity\n\t}\n\tpublic void setRotationSpeed(float x, float y){\n\t\tangularVelocity = x,y\n\t}\n\tpublic void setRotationAcceleration(vector2 newacceleration){\n\t\tangularAcceleration = newacceleration\n\t}\n\tpublic void setRotationAcceleration(float x, float y){\n\t\tangularAcceleration = x,y\n\t}\n}","index":0},{"name":"travelling","content":"package animation\n\ndef lazy travelling(int $indexVar,int $timeVar, int $speed, params $value){\n\tdef end(){\n\t\t$indexVar ++\n\t\t$timeVar = 0\n\t}\n\tforgenerate($c,$value){\n\t\tif($indexVar == $c.index){\n\t\t\tif ($c.count == 10){\n\t\t\t\tint $distance = $eval(((($c.0)-($c.5))^2+(($c.1)-($c.6))^2+(($c.2)-($c.7))^2)^0.5)eval$\n\t\t\t\tint $time = $eval($distance / $speed)\n\n\t\t\t\tanimation.lerpPosition($timeVar,$time,\n\t\t\t\t\t\t$c.0,$c.1,$c.2,$c.3,$c.4,\n\t\t\t\t\t\t$c.5,$c.6,$c.7,$c.8,$c.9,end)\n\t\t\t}\n\t\t\tif ($c.count == 15){\n\t\t\t\tint $distance1 = $eval(((($c.0)-($c.5))^2+(($c.1)-($c.6))^2+(($c.2)-($c.7))^2)^0.5)eval$\n\t\t\t\tint $distance2 = $eval(((($c.5)-($c.10))^2+(($c.6)-($c.11))^2+(($c.7)-($c.12))^2)^0.5)eval$\n\t\t\t\tint $distance3 = $eval(((($c.0)-($c.10))^2+(($c.1)-($c.11))^2+(($c.2)-($c.12))^2)^0.5)eval$\n\t\t\t\tint $distance = $eval(($distance1+$distance2+$distance3)/2)eval$\n\t\t\t\tint $time = $eval($distance / $speed)\n\t\t\t\tanimation.bezier($timeVar,$time,\n\t\t\t\t\t\t$c.0,$c.1,$c.2,$c.3,$c.4,\n\t\t\t\t\t\t$c.5,$c.6,$c.7,$c.8,$c.9,\n\t\t\t\t\t\t$c.10,$c.11,$c.12,$c.13,$c.14,end)\t\n\t\t\t}\n\t\t\trequire $c.count <= 15\n\t\t\trequire $c.count >= 10\n\t\t}\n\t}\n}\n\ndef lazy travellingTime(int $indexVar,int $timeVar, params $value){\n\tdef end(){\n\t\t$indexVar ++\n\t\t$timeVar = 0\n\t}\n\tforgenerate($c,$value){\n\t\tif($indexVar == $c.index){\n\t\t\tif ($c.count == 11){\n\t\t\t\tanimation.lerpPosition($timeVar,$c.0,\n\t\t\t\t\t\t$c.1,$c.2,$c.3,$c.4,$c.5,\n\t\t\t\t\t\t$c.6,$c.7,$c.8,$c.9,$c.10,end)\n\t\t\t}\n\t\t\tif ($c.count == 16){\n\t\t\t\tanimation.bezier($timeVar,$c.0,\n\t\t\t\t\t\t$c.1,$c.2,$c.3,$c.4,$c.5,\n\t\t\t\t\t\t$c.6,$c.7,$c.8,$c.9,$c.10,\n\t\t\t\t\t\t$c.11,$c.12,$c.13,$c.14,$c.15,end)\t\n\t\t\t}\n\t\t\trequire $c.count <= 16\n\t\t\trequire $c.count >= 11\n\t\t}\n\t}\n}","index":0}],"resources":[],"TagsList":{"blocks":{},"functions":{}},"mcTagsList":{"blocks":{},"functions":{"load":{"values":["load"]},"tick":{"values":["main"]}}},"compileOrder":[],"version":{"major":1,"minor":0,"patch":0,"build":40},"compilationSetting":{"TreeMaxSize":20,"FloatPrecision":1000,"removeUselessFile":true,"offuscate":true,"scoreboardValue":"tbms.value","scoreboardConst":"tbms.const","scoreboardTmp":"tbms.tmp","tagsFolder":true,"forcedOffuscation":{},"libraryFolder":["./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/","./lib/shared/","./lib/1_16_5/"],"MCVersion":"1.16.5","ExportAsZip":false,"packformat":6,"CompilerCoreName":"java","isLibrary":false}}