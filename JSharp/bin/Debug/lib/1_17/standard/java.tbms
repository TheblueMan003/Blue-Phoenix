{"projectName":"java","datapackDirectory":null,"resourcesPackDirectory":null,"offuscate":true,"isLibrary":true,"description":"Made With BluePhoenix","files":[{"name":"import","content":"\n","index":0},{"name":"at","content":"package .\n\ndef lazy at(float $x, float $y, float $z, function $action){\n    positioned($x,$y,$z,$action)\n}\n\ndef lazy at(entity $value, function $action){\n    /execute at $value run function $action.name\n}\n\ndef lazy positioned(entity $value, function $action){\n    /execute at $value run function $action.name\n}\n\ndef lazy positioned(float $x, float $y, float $z, function $action){\n    if (__isnb($x,$y,$z)){\n        /execute positioned $x $y $z run function $action.name\n    }\n    else{\n        /summon marker ~ ~ ~ {Tags:[\"at_trg\",\"cur_at_trg\"]}\n        @e[tag=cur_at_trg].x = $x\n        @e[tag=cur_at_trg].y = $y\n        @e[tag=cur_at_trg].z = $z\n        at(@e[tag=cur_at_trg]){\n            untag(@e[tag=cur_at_trg],cur_at_trg)\n            $action()\n        }\n        kill(@e[tag=at_trg])\n    }\n}\ndef lazy aligned(function $func){\n    align(xyz){\n        positioned(~.5 ~ ~.5){\n            $func()\n        }\n    }\n}","index":0},{"name":"clone","content":"package .\n\ndef lazy clone(string $value){\n    /clone $value\n}\n\ndef lazy fill(int sx, int sy, int sz, int ex, int ey, int ez, int $block){\n    int dx, dy, dz\n    if (sx > ex){\n        dx = sx\n        sx = ex\n        ex = dx\n    }\n    if (sy > ey){\n        dy = sy\n        sy = ey\n        ey = dy\n    }\n    if (sz > ez){\n        dz = sz\n        sz = ez\n        ez = dz\n    }\n    /summon marker ~ ~ ~ {Tags:[\"fill_trg\"]}\n    \n    for(int x = sx;x <= ex;x++){\n        @e[tag=fill_trg].x = x\n        for(int y = sy;y <= ey;y++){\n            @e[tag=fill_trg].y = y\n            for(int z = sz;z <= ez;z++){\n                @e[tag=fill_trg].z = z\n                at(@e[tag=fill_trg,limit=1]){\n                    /setblock ~ ~ ~ $block\n                }\n            }\n        }\n    }\n    kill(@e[tag=fill_trg])\n}\n\ndef lazy setblock(int x, int y, int z, int $block){\n    /summon marker ~ ~ ~ {Tags:[\"fill_trg\"]}\n    \n    @e[tag=fill_trg].x = x\n    @e[tag=fill_trg].y = y\n    @e[tag=fill_trg].z = z\n    at(@e[tag=fill_trg,limit=1]){\n        /setblock ~ ~ ~ $block\n    }\n    kill(@e[tag=fill_trg])\n}","index":0},{"name":"constant","content":"package .\n\nconst bool true = true\nconst bool false = false\n\npackage int\n\nconst int minValue = -2147483648\nconst int maxValue = 2147483647\n","index":0},{"name":"rotated","content":"package .\n\ndef lazy facing(entity $value, function $val){\n    /execute facing entity $value feet run function $val.name\n}\n\ndef lazy facing(entity $value, int $eyes, function $val){\n    /execute facing entity $value $eyes run function $val.name\n}\n\ndef lazy facing(int $value, function $val){\n    /execute facing $value run function $val.name\n}\n\ndef lazy facing(int $x,int $y, int $z, function $val){\n    if (__isNb($x) && __isNb($y) && __isNb($z)){\n        /execute facing $x $y $z run function $val.name\n    }\n    else{\n        at($x,$y,$z){\n            /summon marker ~ ~ ~ {Tags:[\"at_trg\"]}\n        }\n        facing(@e[tag=at_trg]){\n            kill(@e[tag=at_trg])\n            $val()\n        }\n    }\n}\n\n\ndef lazy rotated(string $value, function $val){\n    /execute rotated $value run function $val.name\n}","index":0},{"name":"version","content":"package .\n\ndef lazy __version__(){\n    tellraw(@a,(\"═════[ \",blue),(\"$projectName\",aqua),(\" ]═════\",blue))\n    tellraw(@a,(\"Version:\",blue),(\" $projectVersion\",aqua))\n    tellraw(@a,(\"Made with:\",blue),(\" BluePhoenix\",aqua))\n    tellraw(@a,(\"Compiler Core:\",blue),(\" Java 1.17\",aqua))\n    tellraw(@a,(\"════════════════════\",blue))\n}\ndef helper version(){\n    __version__()\n}","index":0},{"name":"store","content":"package .\n\ndef lazy cmdstore(int $var, int $cmd){\n    /execute store result score $var.scoreboard run $cmd\n}\nint lazy cmdstore(int $cmd){\n    define int $var = ret_0\n    /execute store result score $var.scoreboard run $cmd\n}\n\n\ndef lazy print(json $text){\n    /tellraw @a $text\n}\n\ndef null(){\n    \n}","index":0},{"name":"repeat","content":"package .\n\ndef lazy repeat(int $n,function $f){\n    for(int i = 0;i < $n;i++){\n        $f()    \n    }\n}","index":0},{"name":"forceload","content":"package .\n\ndef lazy forceload(int $x1, int $z1, int $x2, int $z2){\n    /forceload add $x1 $z1 $x2 $z2\n}\n\ndef lazy forceunload(int $x1, int $z1, int $x2, int $z2){\n    /forceload remove $x1 $z1 $x2 $z2\n}\n\ndef lazy forceload(int $x1, int $y1, int $z1, int $x2, int $y2, int $z2){\n    /forceload add $x1 $z1 $x2 $z2\n}\n\ndef lazy forceunload(int $x1, int $y1, int $z1, int $x2, int $y2, int $z2){\n    /forceload remove $x1 $z1 $x2 $z2\n}","index":0},{"name":"tag","content":"package .\n\ndef lazy tag(int $tag){\n    require $tag valid_tag\n    /tag @s add $tag\n}\n\ndef lazy tag(entity $entity, int $tag){\n    require $tag valid_tag\n    /tag $entity add $tag\n}\n\ndef lazy untag(int $tag){\n    require $tag valid_tag\n    /tag @s remove $tag\n}\n\ndef lazy untag(entity $entity, int $tag){\n    require $tag valid_tag\n    /tag $entity remove $tag\n}\n\ndef lazy unitag(int $tag){\n    require $tag valid_tag\n    /tag @e remove $tag\n    /tag @s add $tag\n}\n\ndef lazy unitag(entity $entity, int $tag){\n    require $tag valid_tag\n    /tag @e remove $tag\n    /tag $entity add $tag\n}","index":0},{"name":"kill","content":"package .\n\ndef lazy kill(entity $entity){\n    /kill $entity\n}\n\ndef lazy kill(){\n    /kill @s\n}\n\ndef lazy spawnpoint(){\n    /spawnpoint @s ~ ~ ~ ~\n}\n\ndef lazy spawnpoint(entity $entity){\n    /spawnpoint $entity ~ ~ ~ ~\n}\n\ndef lazy spawnpoint(int $x, int $y, int $z){\n    /spawnpoint @s $x $y $z\n}\n\ndef lazy spawnpoint(entity $entity,int $x, int $y, int $z){\n    /spawnpoint $entity $x $y $z ~\n}\n\ndef lazy spawnpoint(entity $entity,int $x, int $y, int $z, int $u){\n    /spawnpoint $entity $x $y $z $u\n}","index":0},{"name":"block","content":"package .\n\ndef lazy setblock(int $block){\n    if (__hasspace($block)){\n        /setblock $block\n    }\n    if (!__hasspace($block)){\n        /setblock ~ ~ ~ $block\n    }\n}\n\ndef lazy setblock(int $x, int $y, int $z, int $block){\n    /setblock $x $y $z $block   \n}\n\ndef lazy setblock(int $x, int $y, int $z, int $block, int $para){\n    /setblock $x $y $z $block $para\n}","index":0},{"name":"clear","content":"package .\n\ndef lazy clear(){\n    /clear @s\n}\n\ndef lazy clear(entity $entity){\n    /clear $entity\n}\n\ndef lazy clear(entity $entity, int $item){\n    /clear $entity $item\n}\n\ndef lazy clear(entity $entity, int $item, int $count){\n    /clear $entity $item $count\n}\n\ndef lazy give(int $item){\n    /give @s $item\n}\n\ndef lazy give(int $item, int $count){\n    /give @s $item $count\n}\n\ndef lazy give(entity $entity, int $item, int $count){\n    /give $entity $item $count\n}","index":0},{"name":"data","content":"package data\n\ndef lazy set(entity $e, int $data){\n    /data merge entity $e $data\n}\n\ndef lazy set(int $data){\n    data.set(@s,$data)\n}\n\ndef lazy copyFromToPath(entity $e1, int $path1, entity $e2, int $path2){\n    /data modify entity $e1 $path1 set from entity $e2 $path2\n}\n\ndef lazy copyFromToPath(int $path1, entity $e2, int $path2){\n    copyFromToPath(@s, $path1, $e2, $path2)\n}\n\ndef lazy copyFrom(entity $e2, int $path){\n    copyFromToPath(@s, $path, $e2, $path)\n}\n\ndef lazy copyFrom(entity $e1, entity $e2,int $path){\n    copyFromToPath($e1, $path, $e2, $path)\n}","index":0},{"name":"predicate","content":"package .\n\npredicate nbt($i){\n    \"condition\": \"minecraft:entity_properties\",\n    \"entity\": \"this\",\n    \"predicate\": {\n        \"nbt\": \"$i\"\n    }\n}\n\npredicate type($i){\n    \"condition\": \"minecraft:entity_properties\",\n    \"entity\": \"this\",\n    \"predicate\": {\n        \"type\": \"$i\"\n    }\n}\n\npredicate team($i){\n    \"condition\": \"minecraft:entity_properties\",\n    \"entity\": \"this\",\n    \"predicate\": {\n        \"team\": \"$i\"\n    }\n}\n\npredicate effect($effect){\n  \"condition\": \"minecraft:entity_properties\",\n  \"entity\": \"this\",\n  \"predicate\": {\n    \"effects\": {\n      \"minecraft:$effect\": {}\n    }\n  }\n}\n\npredicate effect($effect, $amplifier){\n  \"condition\": \"minecraft:entity_properties\",\n  \"entity\": \"this\",\n  \"predicate\": {\n    \"effects\": {\n      \"minecraft:$effect\": {\"amplifier\": $amplifier}\n    }\n  }\n}\n\npredicate effect($effect, $amplifier, $duration){\n  \"condition\": \"minecraft:entity_properties\",\n  \"entity\": \"this\",\n  \"predicate\": {\n    \"effects\": {\n      \"minecraft:$effect\": {\"amplifier\": $amplifier, \"duration\": $duration}\n    }\n  }\n}\n\npredicate effect($effect, $amplifier, $duration, $visible){\n  \"condition\": \"minecraft:entity_properties\",\n  \"entity\": \"this\",\n  \"predicate\": {\n    \"effects\": {\n      \"minecraft:$effect\": {\"amplifier\": $amplifier, \"duration\": $duration, \"visible\": $visible}\n    }\n  }\n}\n","index":0},{"name":"string","content":"package string\n\ndef lazy init(int $string){\n    /summon minecraft:marker ~ ~ ~ {CustomName:'{\"text\":\"$string\"}'},Tags:[\"__str__\"]}\n}","index":0}],"resources":[],"TagsList":{"blocks":{},"functions":{}},"mcTagsList":{"blocks":{},"functions":{"load":{"values":["load"]},"tick":{"values":["main"]}}},"compileOrder":[],"version":{"major":1,"minor":0,"patch":0,"build":81},"compilationSetting":{"TreeMaxSize":20,"FloatPrecision":1000,"removeUselessFile":true,"offuscate":true,"scoreboardValue":"tbms.value","scoreboardConst":"tbms.const","scoreboardTmp":"tbms.tmp","tagsFolder":true,"forcedOffuscation":{},"libraryFolder":["./lib/1_16_5/"],"MCVersion":"1.16.5","ExportAsZip":false,"packformat":6,"rppackformat":7,"CompilerCoreName":"java","Authors":"","generateMAPSFile":true,"generateREADMEFile":true,"opti_FunctionTagsReplace":true,"opti_ExportComment":false,"opti_ShowException":true,"opti_ShowDebug":true,"opti_FileCleanUp":true,"advanced_debug":false,"isLibrary":false}}