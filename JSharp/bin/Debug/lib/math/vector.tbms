{"projectName":"vector","datapackDirectory":null,"offuscate":false,"isLibrary":false,"description":"Made With BluePhoenix","files":[{"name":"import","content":"import exception\nimport math","index":0},{"name":"vector3","content":"package vector\n\nstruct vector3{\n\tfloat x\n\tfloat y\n\tfloat z\n\t\n\tdef lazy __init__(float x, float y,float z){\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.z = z\n\t}\n\n\tdef lazy __set__(float x, float y, float z){\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.z = z\t\n\t}\n\n\tdef lazy __set__(vector3 other){\n\t\tthis.x = other.x\n\t\tthis.y = other.y\n\t\tthis.z = other.z\n\t}\n\t\n\tdef lazy __add__(vector3 other){\n\t\tthis.x += other.x\n\t\tthis.y += other.y\n\t\tthis.z += other.z\n\t}\n\t\n\tdef lazy __sub__(vector3 other){\n\t\tthis.x -= other.x\n\t\tthis.y -= other.y\n\t\tthis.z -= other.z\n\t}\n\n\tdef magnitude():float{\n\t\tfloat tmp1 = math.pow(this.x, 2)\n\t\tfloat tmp2 = math.pow(this.y, 2)\n\t\tfloat tmp3 = math.pow(this.z, 2)\n\t\ttmp1 = tmp1+ tmp2 + tmp3\n\t\ttmp1 = math.sqrt(tmp1)\n\t\treturn(tmp1)\n\t}\n\n\tdef normalize(){\n\t\tfloat mag = magnitude()\n\t\tx /= mag\n\t\ty /= mag\n\t\tz /= mag\n\t}\n\t\n\tdef scalarProd(vector3 other):float{\n\t\tfloat output = 0\n\t\toutput += this.x * this.x\n\t\toutput += this.y * this.y\n\t\toutput += this.z * this.z\n\t\treturn(output)\n\t}\n\t\n\tdef lazy mult(float a){\n\t\tthis.x *= a\n\t\tthis.y *= a\n\t\tthis.z *= a\n\t}\n\t\n\tdef lazy div(float a){\n\t\tthis.x /= a\n\t\tthis.y /= a\n\t\tthis.z /= a\n\t}\n}","index":0},{"name":"vector2","content":"package vector\n\nstruct vector2{\n\tfloat x\n\tfloat y\n\n\tdef lazy __init__(float x, float y){\n\t\tthis.x = x\n\t\tthis.y = y\n\t}\n\n\tdef lazy __set__(float x, float y){\n\t\tthis.x = x\n\t\tthis.y = y\n\t}\n\n\tdef lazy __set__(vector3 other){\n\t\tthis.x = other.x\n\t\tthis.y = other.y\n\t}\n\n \tdef lazy __add__(vector2 other){\n\t\tthis.x += other.x\n\t\tthis.y += other.y\n\t}\n\t\n\tdef lazy __sub__(vector2 other){\n\t\tthis.x -= other.x\n\t\tthis.y -= other.y\n\t}\n\t\n\tdef scalarProd(vector2 other):float{\n\t\tfloat output = 0\n\t\toutput += this.x * this.x\n\t\toutput += this.y * this.y\n\t\treturn(output)\n\t}\n\t\n\tdef lazy mult(float a){\n\t\tthis.x *= a\n\t\tthis.y *= a\n\t}\n\t\n\tdef lazy div(float a){\n\t\tthis.x /= a\n\t\tthis.y /= a\n\t}\n\n\tdef magnitude():float{\n\t\tfloat tmp1 = math.pow(this.x, 2)\n\t\tfloat tmp2 = math.pow(this.y, 2)\n\t\ttmp1 = tmp1+ tmp2\n\t\ttmp1 = math.sqrt(tmp1)\n\t\treturn(tmp1)\n\t}\n\n\tdef normalize(){\n\t\tfloat mag = magnitude()\n\t\tx /= mag\n\t\ty /= mag\n\t}\n}","index":0},{"name":"intvector3","content":"package vector\n\nstruct intvector3{\n\tint x\n\tint y\n\tint z\n\n\tdef lazy __init__(int x, int y, int z){\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.z = z\n\t}\n\n\tdef lazy __set__(int x, int y, int z){\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.z = z\t\n\t}\n\n\tdef lazy __set__(vector3 other){\n\t\tthis.x = other.x\n\t\tthis.y = other.y\n\t\tthis.z = other.z\n\t}\n\n\tdef lazy __add__(intvector3 other){\n\t\tthis.x += other.x\n\t\tthis.y += other.y\n\t\tthis.z += other.z\n\t}\n\t\n\tdef lazy __sub__(intvector3 other){\n\t\tthis.x -= other.x\n\t\tthis.y -= other.y\n\t\tthis.z -= other.z\n\t}\n\t\n\tdef scalarProd(intvector3 other):int{\n\t\tint output = 0\n\t\toutput += this.x * this.x\n\t\toutput += this.y * this.y\n\t\toutput += this.z * this.z\n\t\treturn(output)\n\t}\n\t\n\tdef lazy mult(int a){\n\t\tthis.x *= a\n\t\tthis.y *= a\n\t\tthis.z *= a\n\t}\n\t\n\tdef lazy div(int a){\n\t\tthis.x /= a\n\t\tthis.y /= a\n\t\tthis.z /= a\n\t}\n\n\tdef magnitude():float{\n\t\tfloat tmp1 = math.pow(this.x, 2)\n\t\tfloat tmp2 = math.pow(this.y, 2)\n\t\tfloat tmp3 = math.pow(this.z, 2)\n\t\ttmp1 = tmp1+ tmp2 + tmp3\n\t\ttmp1 = math.sqrt(tmp1)\n\t\treturn(tmp1)\n\t}\n}","index":0},{"name":"intvector2","content":"package vector\n\nstruct intvector2{\n\tint x\n\tint y\n\n\tdef lazy __init__(int x, int y){\n\t\tthis.x = x\n\t\tthis.y = y\n\t}\n\n\tdef lazy __set__(int x, int y){\n\t\tthis.x = x\n\t\tthis.y = y\n\t}\n\n\tdef lazy __set__(vector3 other){\n\t\tthis.x = other.x\n\t\tthis.y = other.y\n\t}\n\n\n\tdef lazy __add__(intvector2 other){\n\t\tthis.x += other.x\n\t\tthis.y += other.y\n\t}\n\t\n\tdef lazy __sub__(intvector2 other){\n\t\tthis.x -= other.x\n\t\tthis.y -= other.y\n\t}\n\t\n\tdef scalarProd(intvector2 other):int{\n\t\tint output = 0\n\t\toutput += this.x * this.x\n\t\toutput += this.y * this.y\n\t\treturn(output)\n\t}\n\t\n\tdef lazy mult(int a){\n\t\tthis.x *= a\n\t\tthis.y *= a\n\t}\n\t\n\tdef lazy div(int a){\n\t\tthis.x /= a\n\t\tthis.y /= a\n\t}\n\n\tdef magnitude():float{\n\t\tfloat tmp1 = math.pow(this.x, 2)\n\t\tfloat tmp2 = math.pow(this.y, 2)\n\t\ttmp1 = tmp1+ tmp2\n\t\ttmp1 = math.sqrt(tmp1)\n\t\treturn(tmp1)\n\t}\n}\n","index":0},{"name":"converter","content":"package vector\n\n\ndef vector3ToIntVector3(vector3 vec):intvector3{\n\tintvector3 output = intvector3(vec.x, vec.y, vec.z)\n\treturn(output)\n}\n\ndef vector3ToVector2(vector3 vec, int axis = 2):vector2{\n\texception.intArgCheck(axis, 0, 3)\n\tvector2 output\n\tswitch(axis){\n\t\t0 -> = output = vector2(vec.y, vec.z)\n\t\t1 -> = output = vector2(vec.x, vec.z)\n\t\t2 -> = output = vector2(vec.x, vec.y)\n\t}\n\treturn(output)\n}\n\ndef vector2ToVector3(vector2 vec, int axis = 2):vector3{\n\texception.intArgCheck(axis, 0, 3)\n\tvector3 output\n\tswitch(axis){\n\t\t0 -> output = vector3(0, vec.x, vec.y)\n\t\t1 -> output = vector3(vec.x, 0 , vec.y)\n\t\t2 -> output = vector3(vec.x, vec.y, 0)\n\t}\n\treturn(output)\n}\n\ndef intVector3ToIntVector2(intvector3 vec, int axis = 2):intvector2{\n\texception.intArgCheck(axis, 0, 3)\n\tintvector2 output\n\tswitch(axis){\n\t\t0 -> = output = intvector2(vec.y, vec.z)\n\t\t1 -> = output = intvector2(vec.x, vec.z)\n\t\t2 -> = output = intvector2(vec.x, vec.y)\n\t}\n\treturn(output)\n}\n\ndef intVector2ToIntVector3(intvector2 vec, int axis = 2):intvector3{\n\texception.intArgCheck(axis, 0, 3)\n\tintvector3 output\n\tswitch(axis){\n\t\t0 -> output = intvector3(0, vec.x, vec.y)\n\t\t1 -> output = intvector3(vec.x, 0, vec.y)\n\t\t2 -> output = intvector3(vec.x, vec.y, 0)\n\t}\n\treturn(output)\n}\n","index":0},{"name":"generator","content":"package vector\n\n\"\"\"\nGive Vector(0,0,0)\n\"\"\"\ndef lazy zeros():vector3{\n\treturn(vector3(0,0,0))\n}\n\n\"\"\"\nGive Vector(1,1,1)\n\"\"\"\ndef lazy ones():vector3{\n\treturn(vector3(1,1,1))\n}\n\n\"\"\"\nReturn Position of Current Entity as vector3\n\"\"\"\ndef vector3FromPos():vector3{\n\treturn(vector3(@s.x, @s.y, @s.z))\n}\n\n\"\"\"\nReturn Motion of Current Entity as vector3\n\"\"\"\ndef vector3FromMotion():vector3{\n\treturn(vector3(@s.motion_x, @s.motion_y, @s.motion_z))\n}\n\n\"\"\"\nReturn Position of Current Entity as intvector3\n\"\"\"\ndef intvector3FromPos():intvector3{\n\treturn(intvector3(@s.x, @s.y, @s.z))\n}\n\n\"\"\"\nReturn Motion of Current Entity as intvector3\n\"\"\"\ndef intvector3FromMotion():vector3{\n\treturn(intvector3(@s.motion_x, @s.motion_y, @s.motion_z))\n}\n\n\"\"\"\nReturn Position of Current Entity as vector2\n\"\"\"\ndef vector2FromPos(int axis = 2):vector2{\n\treturn(vector3ToVector2(vector3(@s.x, @s.y, @s.z), axis))\n}\n\n\"\"\"\nReturn Position of Current Entity as intvector2\n\"\"\"\ndef intvector2FromPos(int axis = 2):intvector2{\n\treturn(intVector3ToIntVector2(intvector3(@s.x, @s.y, @s.z), axis))\n}\n\n\"\"\"\nReturn Motion of Current Entity as vector2\n\"\"\"\ndef vector2FromMotion(int axis = 2):vector2{\n\treturn(vector3ToVector2(vector3(@s.motion_x, @s.motion_y, @s.motion_z), axis))\n}\n\n\"\"\"\nReturn Motion of Current Entity as intvector2\n\"\"\"\ndef intvector2FromMotion(int axis = 2):intvector2{\n\treturn(intVector3ToIntVector2(intvector3(@s.motion_x, @s.motion_y, @s.motion_z), axis))\n}\n\n\"\"\"\nReturn Position as a tripple\n\"\"\"\ndef lazy position():float,float,float{\n\treturn(@s.x,@s.y,@s.z)\n}\n\n\"\"\"\nReturn Position as a tripple of int\n\"\"\"\ndef lazy intPosition():int,int,int{\n\treturn(@s.x,@s.y,@s.z)\n}\n\n\"\"\"\nReturn Motion as a tripple\n\"\"\"\ndef lazy motion():float,float,float{\n\treturn(@s.motion_x,@s.motion_y,@s.motion_z)\n}\n\n\"\"\"\nReturn Motion as a tripple of int\n\"\"\"\ndef lazy intMotion():int,int,int{\n\treturn(@s.motion_x,@s.motion_y,@s.motion_z)\n}","index":0}],"resources":[],"TagsList":{"blocks":{},"functions":{}},"mcTagsList":{"blocks":{},"functions":{"load":{"values":[]},"tick":{"values":[]}}},"compileOrder":[],"version":{"major":1,"minor":0,"patch":0,"build":5}}